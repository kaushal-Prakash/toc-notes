

## ğŸ§© **Context-Free Grammar (CFG)**

A **grammar (G)** is written as:

> **G = (V, T, P, S)**

Where:

* **V** â†’ Set of variables (also called *non-terminals*)

  * e.g., `S`, `A`, `B`, etc.
* **T** â†’ Set of terminals (actual symbols or alphabets)

  * e.g., `a`, `b`, `c`
* **P** â†’ Set of production rules

  * Rules tell how to replace non-terminals with other symbols.
  * Example: `S â†’ aAb`
* **S** â†’ Start symbol

  * The rule where the grammar starts.

ğŸ‘‰ So, CFG means each rule (production) has **one variable on the left-hand side**:
**A â†’ Î±**, where Î± is a combination of terminals and/or variables.

---

## ğŸ§± **Example of a CFG**

```
S â†’ aAb
A â†’ aAb | b
```

This means:

* Start from S.
* You can replace S by `aAb`.
* Then replace A by either `aAb` (to grow) or `b` (to stop).

The strings it generates are:
`aabb`, `aaabbb`, `aaaabbbb`, etc.
â†’ Thatâ€™s the language **{ aâ¿bâ¿ | n â‰¥ 1 }**

---

## ğŸ§  **Chomsky Hierarchy**

This classifies all grammars into **four types** (from most general to most specific):

| Type       | Name                                     | Rules Format   | Machine Equivalent       | Example Rule    | Notes                                       |
| ---------- | ---------------------------------------- | -------------- | ------------------------ | --------------- | ------------------------------------------- |
| **Type 0** | Unrestricted / Phrase-structured Grammar | No restriction | Turing Machine           | Î± â†’ Î²           | Most powerful grammar                       |
| **Type 1** | Context-sensitive Grammar                |                | Linear Bounded Automaton | Î±AÎ² â†’ Î±Î³Î²       | Output cannot be shorter than input         |
| **Type 2** | Context-free Grammar                     |                | Pushdown Automaton       | A â†’ Î±           | Used in programming languages               |
| **Type 3** | Regular Grammar                          |                | Finite Automaton         | A â†’ aB or A â†’ a | Simplest form (used in regular expressions) |

ğŸ’¡ Think of it like this:

```
Regular Grammar âŠ‚ Context-Free Grammar âŠ‚ Context-Sensitive Grammar âŠ‚ Unrestricted Grammar
```

---

## âš™ï¸ **Grammar from Finite Automata (FA)**

You can **convert an automaton into a grammar**.

Let:

```
M = (Q, Î£, Î´, q0, F)
```

Where:

* **Q** â†’ set of states = {qâ‚€, qâ‚, qâ‚‚, ...}
* **Î£** â†’ input symbols (alphabet) = {aâ‚, aâ‚‚, ...}
* **qâ‚€** â†’ start state
* **F** â†’ set of final states
* **Î´** â†’ transition function

We can make a grammar:

> **G = (V, T, P, S)**

Where:

* **V = Q** (each state becomes a variable)
* **T = Î£** (terminals = input symbols)
* **S = qâ‚€** (start variable = start state)
* **P** = set of productions (derived from transitions)

### Example

If automaton has:

```
qâ‚€ --a--> qâ‚
qâ‚ --b--> qâ‚‚
qâ‚‚ is a final state
```

Then grammar rules are:

```
qâ‚€ â†’ a qâ‚
qâ‚ â†’ b qâ‚‚
qâ‚‚ â†’ Îµ   (because qâ‚‚ is final)
```

---

## ğŸ“„ **Summary**

| Concept           | Meaning                                      |
| ----------------- | -------------------------------------------- |
| CFG               | Grammar with one non-terminal on LHS         |
| Components of CFG | (V, T, P, S)                                 |
| Chomsky Hierarchy | Classification of grammar types              |
| Regular Grammar   | Simplest, recognized by Finite Automaton     |
| CFG               | Recognized by Pushdown Automaton             |
| Conversion        | Finite Automaton â†’ Grammar using transitions |

---


## ğŸ§­ **Conversion of FA to Grammar**

To convert a **Finite Automaton (FA)** into a **Grammar (G)**, we follow these steps:

---

### **Step 1:**

If there is a transition in the automaton like

> Î´(qáµ¢, a) = qâ±¼

Then we write a production rule:

> qáµ¢ â†’ a qâ±¼

âœ… This means:
From state `qáµ¢`, on reading symbol `a`, we move to state `qâ±¼`.

---

### **Step 2:**

If `qâ±¼` is a **final state**, then we add another rule:

> qâ±¼ â†’ Îµ

âœ… This means:
Once we reach a final state, we can **stop** (produce an empty string).

---

### Example:

**Question:**

> Obtain a grammar to generate strings consisting of any number of â€˜aâ€™s.

---

### **Step 1: Draw the automaton**

```
       a
   +------+
   â†“      |
â†’ (A) ----+
   â†‘ final state
```

* Start state = `A`
* Final state = `A`
* Input = `a`
* Transition = On `a`, stay in the same state (`A â†’ aA`)

---

### **Step 2: Write Grammar Rules**

From the transition:

```
A â†’ aA
```

Since `A` is also a **final state**, we add:

```
A â†’ Îµ
```

---

### âœ… **Final Grammar:**

```
G = (V, T, P, S)
```

Where:

* **V** = { A }
* **T** = { a }
* **P** = { A â†’ aA | Îµ }
* **S** = A

---

### **This Grammar Generates:**

```
Îµ, a, aa, aaa, aaaa, ...
```

ğŸ‘‰ Meaning: any number of â€˜aâ€™s (including zero).
Thatâ€™s the **language { aâ¿ | n â‰¥ 0 }**

---

### **Another Example in Your Notes**

Thereâ€™s also an example with **two states** â€” `S` and `A`:

* From `S`, on `a`, go to `A`
* From `A`, on `a`, stay in `A` (loop)
* `A` is a final state

So transitions are:

```
Î´(S, a) = A
Î´(A, a) = A
```

Hence, grammar rules:

```
S â†’ aA
A â†’ aA | Îµ
```

âœ… This generates strings: `a`, `aa`, `aaa`, ...
Thatâ€™s the language **{ aâ¿ | n â‰¥ 1 }**

---

### ğŸ”¹ Summary

| Concept            | Meaning                          |
| ------------------ | -------------------------------- |
| Î´(qáµ¢, a) = qâ±¼      | Transition in FA                 |
| qáµ¢ â†’ a qâ±¼          | Grammar rule for that transition |
| qâ±¼ final state     | Add rule `qâ±¼ â†’ Îµ`                |
| S (start variable) | Same as start state of FA        |
| Îµ                  | Empty string (means stop)        |

---
